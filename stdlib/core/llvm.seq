# LLVM bindings for Seq

#######
# int #
#######
# basic arithmetic
@llvm
def add_int(a: int, b: int) -> int:
    entry:
        %tmp = add i64 %a, %b
        ret i64 %tmp

@llvm
def sub_int(a: int, b: int) -> int:
    entry:
        %tmp = sub i64 %a, %b
        ret i64 %tmp

@llvm
def mul_int(a: int, b: int) -> int:
    entry:
        %tmp = mul i64 %a, %b
        ret i64 %tmp

@llvm
def div_int(a: int, b: int) -> int:
    entry:
        %tmp = sdiv i64 %a, %b
        ret i64 %tmp

@llvm
def mod_int(a: int, b: int) -> int:
    entry:
        %tmp = srem i64 %a, %b
        ret i64 %tmp

# bitwise
@llvm
def inv_int(a: int) -> int:
    entry:
        %tmp = xor i64 %a, -1
        ret i64 %tmp

@llvm
def and_int(a: int, b: int) -> int:
    entry:
        %tmp = and i64 %a, %b
        ret i64 %tmp

@llvm
def or_int(a: int, b: int) -> int:
    entry:
        %tmp = or i64 %a, %b
        ret i64 %tmp

@llvm
def xor_int(a: int, b: int) -> int:
    entry:
        %tmp = xor i64 %a, %b
        ret i64 %tmp

@llvm
def shr_int(a: int, b: int) -> int:
    entry:
        %tmp = ashr i64 %a, %b
        ret i64 %tmp

@llvm
def shl_int(a: int, b: int) -> int:
    entry:
        %tmp = shl i64 %a, %b
        ret i64 %tmp

# comparisons
@llvm
def eq_int(a: int, b: int) -> bool:
    entry:
        %tmp = icmp eq i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def ne_int(a: int, b: int) -> bool:
    entry:
        %tmp = icmp ne i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def lt_int(a: int, b: int) -> bool:
    entry:
        %tmp = icmp slt i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def gt_int(a: int, b: int) -> bool:
    entry:
        %tmp = icmp sgt i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def le_int(a: int, b: int) -> bool:
    entry:
        %tmp = icmp sle i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def ge_int(a: int, b: int) -> bool:
    entry:
        %tmp = icmp sge i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

#########
# float #
#########
# basic arithmetic
@llvm
def add_float(a: float, b: float) -> float:
    entry:
        %tmp = fadd double %a, %b
        ret double %tmp

@llvm
def sub_float(a: float, b: float) -> float:
    entry:
        %tmp = fsub double %a, %b
        ret double %tmp

@llvm
def mul_float(a: float, b: float) -> float:
    entry:
        %tmp = fmul double %a, %b
        ret double %tmp

@llvm
def div_float(a: float, b: float) -> float:
    entry:
        %tmp = fdiv double %a, %b
        ret double %tmp

@llvm
def mod_float(a: float, b: float) -> float:
    entry:
        %tmp = frem double %a, %b
        ret double %tmp

# comparisons
@llvm
def eq_float(a: float, b: float) -> bool:
    entry:
        %tmp = fcmp oeq double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def ne_float(a: float, b: float) -> bool:
    entry:
        %tmp = fcmp one double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def lt_float(a: float, b: float) -> bool:
    entry:
        %tmp = fcmp olt double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def gt_float(a: float, b: float) -> bool:
    entry:
        %tmp = fcmp ogt double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def le_float(a: float, b: float) -> bool:
    entry:
        %tmp = fcmp ole double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

@llvm
def ge_float(a: float, b: float) -> bool:
    entry:
        %tmp = fcmp oge double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

# functions
@llvm
def sqrt_float(a: float) -> float:
    declare double @llvm.sqrt.f64(double %a)
    entry:
        %tmp = call double @llvm.sqrt.f64(double %a)
        ret double %tmp

@llvm
def sin_float(a: float) -> float:
    declare double @llvm.sin.f64(double %a)
    entry:
        %tmp = call double @llvm.sin.f64(double %a)
        ret double %tmp

@llvm
def cos_float(a: float) -> float:
    declare double @llvm.cos.f64(double %a)
    entry:
        %tmp = call double @llvm.cos.f64(double %a)
        ret double %tmp

@llvm
def exp_float(a: float) -> float:
    declare double @llvm.exp.f64(double %a)
    entry:
        %tmp = call double @llvm.exp.f64(double %a)
        ret double %tmp

@llvm
def exp2_float(a: float) -> float:
    declare double @llvm.exp2.f64(double %a)
    entry:
        %tmp = call double @llvm.exp2.f64(double %a)
        ret double %tmp

@llvm
def log_float(a: float) -> float:
    declare double @llvm.log.f64(double %a)
    entry:
        %tmp = call double @llvm.log.f64(double %a)
        ret double %tmp

@llvm
def log10_float(a: float) -> float:
    declare double @llvm.log10.f64(double %a)
    entry:
        %tmp = call double @llvm.log10.f64(double %a)
        ret double %tmp

@llvm
def log2_float(a: float) -> float:
    declare double @llvm.log2.f64(double %a)
    entry:
        %tmp = call double @llvm.log2.f64(double %a)
        ret double %tmp

@llvm
def abs_float(a: float) -> float:
    declare double @llvm.fabs.f64(double %a)
    entry:
        %tmp = call double @llvm.fabs.f64(double %a)
        ret double %tmp

@llvm
def floor_float(a: float) -> float:
    declare double @llvm.floor.f64(double %a)
    entry:
        %tmp = call double @llvm.floor.f64(double %a)
        ret double %tmp

@llvm
def ceil_float(a: float) -> float:
    declare double @llvm.ceil.f64(double %a)
    entry:
        %tmp = call double @llvm.ceil.f64(double %a)
        ret double %tmp

@llvm
def trunc_float(a: float) -> float:
    declare double @llvm.trunc.f64(double %a)
    entry:
        %tmp = call double @llvm.trunc.f64(double %a)
        ret double %tmp

@llvm
def rint_float(a: float) -> float:
    declare double @llvm.rint.f64(double %a)
    entry:
        %tmp = call double @llvm.rint.f64(double %a)
        ret double %tmp

@llvm
def nearbyint_float(a: float) -> float:
    declare double @llvm.nearbyint.f64(double %a)
    entry:
        %tmp = call double @llvm.nearbyint.f64(double %a)
        ret double %tmp

@llvm
def round_float(a: float) -> float:
    declare double @llvm.round.f64(double %a)
    entry:
        %tmp = call double @llvm.round.f64(double %a)
        ret double %tmp

@llvm
def pow_float(a: float, b: float) -> float:
    declare double @llvm.pow.f64(double %a, double %b)
    entry:
        %tmp = call double @llvm.pow.f64(double %a, double %b)
        ret double %tmp

@llvm
def min_float(a: float, b: float) -> float:
    declare double @llvm.minnum.f64(double %a, double %b)
    entry:
        %tmp = call double @llvm.minnum.f64(double %a, double %b)
        ret double %tmp

@llvm
def max_float(a: float, b: float) -> float:
    declare double @llvm.maxnum.f64(double %a, double %b)
    entry:
        %tmp = call double @llvm.maxnum.f64(double %a, double %b)
        ret double %tmp

@llvm
def copysign_float(a: float, b: float) -> float:
    declare double @llvm.copysign.f64(double %a, double %b)
    entry:
        %tmp = call double @llvm.copysign.f64(double %a, double %b)
        ret double %tmp

@llvm
def fma_float(a: float, b: float, c: float) -> float:
    declare double @llvm.fma.f64(double %a, double %b, double %c)
    entry:
        %tmp = call double @llvm.fma.f64(double %a, double %b, double %c)
        ret double %tmp

#################
# int <-> float #
#################
@llvm
def int_to_float(a: int) -> float:
    entry:
        %tmp = sitofp i64 %a to double
        ret double %tmp

@llvm
def float_to_int(a: float) -> int:
    entry:
        %tmp = fptosi double %a to i64
        ret i64 %tmp

#######
# str #
#######
@llvm
def memcpy(dest: ptr[byte], src: ptr[byte], len: int) -> void:
    declare void @llvm.memcpy.p0i8.p0i8.i64(i8* %dest, i8* %src, i64 %len, i32 %align, i1 %isvolatile)
    entry:
        call void @llvm.memcpy.p0i8.p0i8.i64(i8* %dest, i8* %src, i64 %len, i32 0, i1 false)
        ret void

@llvm
def memmove(dest: ptr[byte], src: ptr[byte], len: int) -> void:
    declare void @llvm.memmove.p0i8.p0i8.i64(i8* %dest, i8* %src, i64 %len, i32 %align, i1 %isvolatile)
    entry:
        call void @llvm.memmove.p0i8.p0i8.i64(i8* %dest, i8* %src, i64 %len, i32 0, i1 false)
        ret void

@llvm
def memset(dest: ptr[byte], val: byte, len: int) -> void:
    declare void @llvm.memset.p0i8.i64(i8* %dest, i8 %val, i64 %len, i32 %align, i1 %isvolatile)
    entry:
        call void @llvm.memset.p0i8.i64(i8* %dest, i8 %val, i64 %len, i32 0, i1 false)
        ret void
