# OpenMP interface
# Ref: https://github.com/llvm/llvm-project/tree/main/openmp
Routine = Function[[i32, cobj], i32]

@tuple
class Ident:
    reserved_1: i32
    flags: i32
    reserved_2: i32
    reserved_3: i32
    psource: cobj

@tuple
class LRData:
    routine: Routine

@tuple
class Task:
    shareds: cobj
    routine: Routine
    flags: i32
    x: LRData
    y: LRData

@tuple
class TaskWithPrivates[T]:
    task: Task
    data: T

DEFAULT_SRC = ";unknown;unknown;0;0;;".ptr
DEFAULT_LOC = Ident(i32(0), i32(2), i32(0), i32(0), DEFAULT_SRC)

def _default_loc():
    return __ptr__(DEFAULT_LOC)

def _single_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_single(Ptr[Ident], i32) -> i32
    return int(__kmpc_single(loc_ref, i32(gtid)))

def _single_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_single(Ptr[Ident], i32)
    __kmpc_end_single(loc_ref, i32(gtid))

def _master_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_master(Ptr[Ident], i32) -> i32
    return int(__kmpc_master(loc_ref, i32(gtid)))

def _master_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_master(Ptr[Ident], i32)
    __kmpc_end_master(loc_ref, i32(gtid))

def _ordered_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_ordered(Ptr[Ident], i32) -> i32
    return int(__kmpc_ordered(loc_ref, i32(gtid)))

def _ordered_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_ordered(Ptr[Ident], i32)
    __kmpc_end_ordered(loc_ref, i32(gtid))

def _task_alloc(loc_ref: Ptr[Ident], gtid: int, flags: int, size_of_task: int, size_of_shareds: int, task_entry: Routine):
    from C import __kmpc_omp_task_alloc(Ptr[Ident], i32, i32, int, int, Routine) -> cobj
    from internal.gc import add_roots
    task_handle = __kmpc_omp_task_alloc(loc_ref, i32(gtid), i32(flags), size_of_task, size_of_shareds, task_entry)
    base_offset = size_of_task - size_of_shareds
    add_roots(task_handle + base_offset, task_handle + size_of_task)
    return task_handle

def _task_run(loc_ref: Ptr[Ident], gtid: int, new_task: cobj):
    from C import __kmpc_omp_task(Ptr[Ident], i32, cobj) -> i32
    return int(__kmpc_omp_task(loc_ref, i32(gtid), new_task))

def _barrier(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_barrier(Ptr[Ident], i32)
    __kmpc_barrier(loc_ref, i32(gtid))

def _static_init(loc_ref: Ptr[Ident], gtid: int, schedtype: int, loop: range, incr: int, chunk: int):
    from C import __kmpc_for_static_init_8(Ptr[Ident], i32, i32, Ptr[i32], Ptr[int], Ptr[int], Ptr[int], int, int)
    last = i32(0)
    lower = 0
    upper = len(loop) - 1
    stride = 1
    __kmpc_for_static_init_8(loc_ref, i32(gtid), i32(schedtype), __ptr__(last), __ptr__(lower), __ptr__(upper), __ptr__(stride), incr, chunk)
    return range(loop._get(lower), loop._get(upper + 1), loop.step)

def _static_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_for_static_fini(Ptr[Ident], i32)
    __kmpc_for_static_fini(loc_ref, i32(gtid))

def _fork_call(microtask: cobj, args):
    from C import __kmpc_fork_call(Ptr[Ident], i32, cobj, ...)
    loc_ref = _default_loc()  # TODO: pass real loc?
    __kmpc_fork_call(loc_ref, i32(1), microtask, __ptr__(args))

def _static_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    def _static_loop_body_stub(i, args):
        pass

    start, stop, step, extra = args[0]
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    loop = range(start, stop, step)
    subloop = _static_init(loc_ref, gtid, schedtype=34, loop=loop, incr=1, chunk=1)
    for i in subloop:
        _static_loop_body_stub(i, extra)
    _static_fini(loc_ref, gtid)

# P = privates; tuple of types
# S = shareds; tuple of pointers
def _spawn_and_run_task[P,S](loc_ref: Ptr[Ident], gtid: int, routine: cobj, priv: P, shared: S):
    from internal.gc import sizeof

    TaskThunk = TaskWithPrivates[P]
    flags = 1
    size_of_kmp_task_t = sizeof[TaskThunk]()
    size_of_privs = sizeof[P]()
    size_of_shareds = sizeof[S]()
    loc_ref = _default_loc()

    task = Ptr[TaskThunk](_task_alloc(loc_ref, gtid, flags, size_of_kmp_task_t, size_of_shareds, Routine(routine)))
    if staticlen(shared) != 0:
        shared_ptr = task[0].task.shareds
        str.memcpy(shared_ptr, __ptr__(shared).as_byte(), size_of_shareds)
    if staticlen(priv) != 0:
        priv_ptr = task.as_byte() + sizeof[Task]()
        str.memcpy(priv_ptr, __ptr__(priv).as_byte(), size_of_privs)

    _task_run(loc_ref, gtid, task.as_byte())

# Note: this is different than OpenMP's "taskloop" -- this template simply
# spawns a new task for each loop iteration.
def _task_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    def _routine_stub[P,S](gtid: i32, data: cobj):
        def _task_loop_body_stub(priv, shared):
            pass

        task = Ptr[TaskWithPrivates[P]](data)[0]
        priv = task.data
        if staticlen(S()) != 0:
            shared = Ptr[S](task.task.shareds)[0]
            _task_loop_body_stub(priv, shared)
        else:
            shared = ()
            _task_loop_body_stub(priv, shared)
        return i32(0)

    def _insert_new_loop_var(i, priv, shared):
        return priv, shared

    iterable, priv, shared = args[0]
    P = typeof(priv)
    S = typeof(shared)

    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()

    if _single_begin(loc_ref, gtid) != 0:
        try:
            for i in iterable:
                priv, shared = _insert_new_loop_var(i, priv, shared)
                _spawn_and_run_task(loc_ref, gtid, _routine_stub[P,S].__raw__(), priv, shared)
        finally:
            _single_end(loc_ref, gtid)

    _barrier(loc_ref, gtid)

def get_num_threads():
    from C import omp_get_num_threads() -> i32
    return int(omp_get_num_threads())

def get_thread_num():
    from C import omp_get_thread_num() -> i32
    return int(omp_get_thread_num())

def get_max_threads():
    from C import omp_get_max_threads() -> i32
    return int(omp_get_max_threads())

def get_num_procs():
    from C import omp_get_num_procs() -> i32
    return int(omp_get_num_procs())

def set_num_threads(num_threads: int):
    from C import omp_set_num_threads(i32)
    omp_set_num_threads(i32(num_threads))

def in_parallel():
    from C import omp_in_parallel() -> i32
    return bool(omp_in_parallel())

def set_dynamic(dynamic_threads: bool = True):
    from C import omp_set_dynamic(i32)
    omp_set_dynamic(i32(1 if dynamic_threads else 0))

def get_dynamic():
    from C import omp_get_dynamic() -> i32
    return bool(omp_get_dynamic())

def get_cancellation():
    from C import omp_get_cancellation() -> i32
    return bool(omp_get_cancellation())

''' # deprecated
def set_nested(nested: bool = True):
    from C import omp_set_nested(i32)
    omp_set_nested(i32(1 if nested else 0))

def get_nested():
    from C import omp_get_nested() -> i32
    return bool(omp_get_nested())
'''

def set_schedule(kind: str, chunk_size: int = 0):
    from C import omp_set_schedule(i32, i32)
    if kind == 'static':
        omp_set_schedule(i32(1), i32(chunk_size))
    elif kind == 'dynamic':
        omp_set_schedule(i32(2), i32(chunk_size))
    elif kind == 'guided':
        omp_set_schedule(i32(3), i32(chunk_size))
    elif kind == 'auto':
        if chunk_size != 0:
            raise ValueError('cannot specify chunk size for auto schedule')
        omp_set_schedule(i32(4), i32(chunk_size))
    else:
        raise ValueError("invalid schedule kind; valid ones are: 'static', 'dynamic', 'guided', 'auto'")

def get_schedule():
    from C import omp_get_schedule(Ptr[i32], Ptr[i32])
    kind_code = i32(0)
    chunk_size = i32(0)
    omp_get_schedule(__ptr__(kind_code), __ptr__(chunk_size))
    idx = int(kind_code)
    kind = ('static', 'dynamic', 'guided', 'auto')[idx - 1] if 1 < idx <= 4 else 'unknown'
    return kind, int(chunk_size)

def get_thread_limit():
    from C import omp_get_thread_limit() -> i32
    return int(omp_get_thread_limit())

def set_max_active_levels(max_levels: int):
    from C import omp_set_max_active_levels(i32)
    omp_set_max_active_levels(i32(max_levels))

def get_max_active_levels():
    from C import omp_get_max_active_levels() -> i32
    return int(omp_get_max_active_levels())

def get_level():
    from C import omp_get_level() -> i32
    return int(omp_get_level())

def get_ancestor_thread_num(level: int):
    from C import omp_get_ancestor_thread_num(i32) -> i32
    return int(omp_get_ancestor_thread_num(i32(level)))

def get_team_size(level: int):
    from C import omp_get_team_size(i32) -> i32
    return int(omp_get_team_size(i32(level)))

def get_active_level():
    from C import omp_get_active_level() -> i32
    return int(omp_get_active_level())

def in_final():
    from C import omp_in_final() -> i32
    return bool(omp_in_final())

def get_proc_bind():
    from C import omp_get_proc_bind() -> i32
    result = int(omp_get_proc_bind())
    if result < 0 or result > 4:
        return 'unknown'
    return ('false', 'true', 'master', 'close', 'spread')[result]

def set_default_device(device_num: int):
    from C import omp_set_default_device(i32)
    omp_set_default_device(i32(device_num))

def get_default_device():
    from C import omp_get_default_device() -> i32
    return int(omp_get_default_device())

def get_num_devices():
    from C import omp_get_num_devices() -> i32
    return int(omp_get_num_devices())

def get_num_teams():
    from C import omp_get_num_teams() -> i32
    return int(omp_get_num_teams())

def get_team_num():
    from C import omp_get_team_num() -> i32
    return int(omp_get_team_num())

def is_initial_device():
    from C import omp_is_initial_device() -> i32
    return bool(omp_is_initial_device())

def get_wtime():
    from C import omp_get_wtime() -> float
    return omp_get_wtime()

def get_wtick():
    from C import omp_get_wtick() -> float
    return omp_get_wtick()

def single(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        if _single_begin(loc, gtid) != 0:
            try:
                func(*args, **kwargs)
            finally:
                _single_end(loc, gtid)
    return _wrapper

def master(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        if _master_begin(loc, gtid) != 0:
            try:
                func(*args, **kwargs)
            finally:
                _master_end(loc, gtid)
    return _wrapper

def ordered(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        if _ordered_begin(loc, gtid) != 0:
            try:
                func(*args, **kwargs)
            finally:
                _ordered_end(loc, gtid)
    return _wrapper
